<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Avatar Bone Lab - Touch & Adjust</title>
<style>
    body { margin:0; display:flex; font-family:'Segoe UI', sans-serif; color:white; background:#111; overflow: hidden;}
    #viewer { flex:1; height:100vh; background: radial-gradient(circle, #333 0%, #111 100%); cursor: crosshair;}
    #controls { width:400px; background:#222; padding:20px; overflow-y:auto; height:100vh; border-left:1px solid #444; }
    .control-group { margin-bottom:15px; padding:12px; background:#2a2a2a; border-radius:8px; border:1px solid #444; }
    h3 { margin:0 0 10px 0; font-size:13px; color:#00d4ff; text-transform: uppercase; }
    label { display:block; font-size:10px; color:#888; margin-top: 5px;}
    .slider-row { display:flex; align-items:center; gap:8px; margin-bottom:2px;}
    input[type=range] { flex:1; accent-color: #00d4ff; }
    span { font-size:10px; width:35px; font-family:monospace; color: #00d4ff; }
    button { width:100%; padding:12px; background:#00d4ff; border:none; color:#111; border-radius:5px; cursor:pointer; font-weight:bold; margin-top:10px; }
    textarea { width:100%; height:100px; background:#000; color:#0f0; border:1px solid #444; margin-top:10px; font-family:monospace; font-size:11px; }
    .status { font-size: 11px; color: #ffeb3b; margin-bottom: 10px; font-style: italic;}
</style>
</head>
<body>

<div id="viewer"></div>

<div id="controls">
    <h2>Touch & Adjust Lab</h2>
    <div class="status" id="status">Click a bone in the 3D view to select it</div>

    <div class="control-group">
        <h3>Current Bone Rotation</h3>
        <div class="slider-row"><label>X</label><input type="range" id="curX" min="-3.14" max="3.14" step="0.01" value="0"><span id="vcurX">0</span></div>
        <div class="slider-row"><label>Y</label><input type="range" id="curY" min="-3.14" max="3.14" step="0.01" value="0"><span id="vcurY">0</span></div>
        <div class="slider-row"><label>Z</label><input type="range" id="curZ" min="-3.14" max="3.14" step="0.01" value="0"><span id="vcurZ">0</span></div>
    </div>

    <button onclick="copyData()">Export Thinking Pose</button>
    <p style="font-size: 10px; color: #666;">Note: Adjust all 4 bones (Upper, Lower, Hand, Head) then click Export.</p>
    <textarea id="output" readonly></textarea>
</div>

<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';
import { TransformControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/TransformControls.js';

let scene, camera, renderer, orbit, tControls, model;
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let selectedBone = null;

let bones = { r_upper: null, r_lower: null, r_hand: null, head: null };

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(30, (window.innerWidth - 400) / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.4, 3.5);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth-400, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.getElementById('viewer').appendChild(renderer.domElement);

    orbit = new OrbitControls(camera, renderer.domElement);
    orbit.target.set(0, 1.4, 0);

    // Transform Controls Setup
    tControls = new TransformControls(camera, renderer.domElement);
    tControls.setMode('rotate'); // Only rotate for bones
    tControls.addEventListener('dragging-changed', (e) => orbit.enabled = !e.value);
    
    // Sync sliders when mouse moves gizmo
    tControls.addEventListener('change', () => {
        if(selectedBone) {
            updateSlidersFromBone(selectedBone);
        }
    });
    scene.add(tControls);

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const d = new THREE.DirectionalLight(0xffffff, 0.8);
    d.position.set(5,10,7);
    scene.add(d);

    const loader = new GLTFLoader();
    loader.load('/assets/character.glb', gltf => {
        model = gltf.scene;
        model.rotation.y = Math.PI;
        
        // Visual Bone Helpers (uncomment to see skeleton)
        // const helper = new THREE.SkeletonHelper(model);
        // scene.add(helper);

        model.traverse(n => {
            if(n.isBone){
                if(n.name === "J_Bip_R_UpperArm") bones.r_upper = n;
                if(n.name === "J_Bip_R_LowerArm") bones.r_lower = n;
                if(n.name === "J_Bip_R_Hand") bones.r_hand = n;
                if(n.name.toLowerCase().includes("head") && !n.name.includes("End")) bones.head = n;
            }
        });
        scene.add(model);
    });

    // Mouse click to select bone
    window.addEventListener('mousedown', onMouseDown);
    
    // Manual Slider Input
    const sliders = ['curX', 'curY', 'curZ'];
    sliders.forEach(id => {
        document.getElementById(id).addEventListener('input', (e) => {
            if(selectedBone) {
                selectedBone.rotation[id.slice(-1).toLowerCase()] = parseFloat(e.target.value);
                document.getElementById('v'+id).innerText = e.target.value;
            }
        });
    });

    animate();
}

function onMouseDown(event) {
    // Only check if clicking the viewer
    if (event.clientX > window.innerWidth - 400) return;

    mouse.x = (event.clientX / (window.innerWidth - 400)) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(model.children, true);

    if (intersects.length > 0) {
        // Find the closest bone to the click point
        let obj = intersects[0].object;
        let boneToAttach = null;

        // Traverse up to find the bone influencing this part of the mesh
        if(obj.isSkinnedMesh) {
            // This is a simplified logic: usually you'd check bone weights, 
            // but clicking near the head/arms usually hits specific sub-meshes.
            // Let's toggle through your mapped bones based on proximity or name
            const clickedName = obj.name.toLowerCase();
            if(clickedName.includes('head')) boneToAttach = bones.head;
            else if(clickedName.includes('arm')) boneToAttach = bones.r_upper; // Default
            else boneToAttach = obj.parent; // Fallback
        }

        // For this specific VRM/GLB rig, let's allow manual cycle or direct select
        // Better yet: use the intersects to find the bone name
        if(boneToAttach) {
            selectBone(boneToAttach);
        }
    }
}

function selectBone(bone) {
    selectedBone = bone;
    tControls.attach(bone);
    document.getElementById('status').innerText = "Selected: " + bone.name;
    updateSlidersFromBone(bone);
}

function updateSlidersFromBone(bone) {
    ['x','y','z'].forEach(axis => {
        const val = bone.rotation[axis].toFixed(2);
        const id = 'cur' + axis.toUpperCase();
        document.getElementById(id).value = val;
        document.getElementById('v' + id).innerText = val;
    });
}

function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

window.copyData = () => {
    const data = {
        thinking_pose: {
            R_Upper: { x: +bones.r_upper.rotation.x.toFixed(2), y: +bones.r_upper.rotation.y.toFixed(2), z: +bones.r_upper.rotation.z.toFixed(2) },
            R_Lower: { x: +bones.r_lower.rotation.x.toFixed(2), y: +bones.r_lower.rotation.y.toFixed(2), z: +bones.r_lower.rotation.z.toFixed(2) },
            R_Hand:  { x: +bones.r_hand.rotation.x.toFixed(2),  y: +bones.r_hand.rotation.y.toFixed(2), z: +bones.r_hand.rotation.z.toFixed(2) },
            Head:    { x: +bones.head.rotation.x.toFixed(2),    y: +bones.head.rotation.y.toFixed(2),    z: +bones.head.rotation.z.toFixed(2) }
        }
    };
    document.getElementById('output').value = JSON.stringify(data, null, 2);
}

init();
</script>
</body>
</html>